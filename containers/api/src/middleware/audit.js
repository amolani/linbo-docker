/**
 * LINBO Docker - Audit Logging Middleware
 * Records all API actions for compliance and debugging
 */

// Prisma is optional — audit logging degrades silently when DB is unavailable
let prisma = null;
try {
  prisma = require('../lib/prisma').prisma;
} catch {}

const { v4: uuidv4 } = require('uuid');

/**
 * Generate unique request ID
 */
function generateRequestId() {
  return uuidv4();
}

/**
 * Middleware: Add request ID to all requests
 */
function requestId(req, res, next) {
  req.requestId = req.headers['x-request-id'] || generateRequestId();
  res.setHeader('X-Request-ID', req.requestId);
  next();
}

/**
 * Create audit log entry
 * @param {object} params - Audit log parameters
 */
async function createAuditLog({
  actor,
  actorType = 'user',
  action,
  targetType,
  targetId,
  targetName,
  changes,
  status = 'success',
  errorMessage,
  ipAddress,
  userAgent,
  requestId,
}) {
  if (!prisma) return; // No DB — skip audit silently

  try {
    await prisma.auditLog.create({
      data: {
        actor,
        actorType,
        action,
        targetType,
        targetId,
        targetName,
        changes,
        status,
        errorMessage,
        ipAddress,
        userAgent,
        requestId,
      },
    });
  } catch (error) {
    console.error('Failed to create audit log:', error);
  }
}

/**
 * Extract client IP from request
 */
function getClientIp(req) {
  return (
    req.headers['x-forwarded-for']?.split(',')[0]?.trim() ||
    req.headers['x-real-ip'] ||
    req.socket?.remoteAddress ||
    null
  );
}

/**
 * Middleware factory: Audit specific actions
 * @param {string} action - Action name (e.g., 'host.create', 'config.update')
 * @param {object} options - Configuration options
 */
function auditAction(action, options = {}) {
  const {
    getTargetType = () => action.split('.')[0],
    getTargetId = (req) => req.params.id,
    getTargetName = () => null,
    getChanges = (req) => req.body,
  } = options;

  return async (req, res, next) => {
    // Store original json method
    const originalJson = res.json.bind(res);

    // Override json to capture response
    res.json = async (data) => {
      const status = res.statusCode >= 400 ? 'error' : 'success';
      const errorMessage = status === 'error' ? data?.error?.message : null;

      await createAuditLog({
        actor: req.user?.username || 'anonymous',
        actorType: req.apiKey ? 'api_key' : 'user',
        action,
        targetType: getTargetType(req),
        targetId: getTargetId(req, data),
        targetName: getTargetName(req, data),
        changes: getChanges(req),
        status,
        errorMessage,
        ipAddress: getClientIp(req),
        userAgent: req.headers['user-agent'],
        requestId: req.requestId,
      });

      return originalJson(data);
    };

    next();
  };
}

/**
 * Middleware: Audit all write operations (POST, PUT, PATCH, DELETE)
 */
function auditWrites(req, res, next) {
  const method = req.method.toUpperCase();
  const writeMethods = ['POST', 'PUT', 'PATCH', 'DELETE'];

  if (!writeMethods.includes(method)) {
    return next();
  }

  // Determine action from method and path
  const pathParts = req.path.split('/').filter(Boolean);
  const resource = pathParts[pathParts.length - 2] || pathParts[pathParts.length - 1];

  const actionMap = {
    POST: 'create',
    PUT: 'update',
    PATCH: 'update',
    DELETE: 'delete',
  };

  const action = `${resource}.${actionMap[method]}`;

  return auditAction(action, {
    getTargetId: (req, data) => req.params.id || data?.data?.id,
    getTargetName: (req, data) => data?.data?.name || data?.data?.hostname,
  })(req, res, next);
}

/**
 * Query audit logs with filters
 * @param {object} filters - Query filters
 */
async function queryAuditLogs({
  actor,
  action,
  targetType,
  targetId,
  status,
  startDate,
  endDate,
  page = 1,
  limit = 50,
}) {
  if (!prisma) {
    return { data: [], pagination: { page, limit, total: 0, pages: 0 } };
  }

  const where = {};

  if (actor) where.actor = actor;
  if (action) where.action = { contains: action };
  if (targetType) where.targetType = targetType;
  if (targetId) where.targetId = targetId;
  if (status) where.status = status;
  if (startDate || endDate) {
    where.timestamp = {};
    if (startDate) where.timestamp.gte = new Date(startDate);
    if (endDate) where.timestamp.lte = new Date(endDate);
  }

  const [logs, total] = await Promise.all([
    prisma.auditLog.findMany({
      where,
      orderBy: { timestamp: 'desc' },
      skip: (page - 1) * limit,
      take: limit,
    }),
    prisma.auditLog.count({ where }),
  ]);

  return {
    data: logs,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
    },
  };
}

module.exports = {
  requestId,
  createAuditLog,
  getClientIp,
  auditAction,
  auditWrites,
  queryAuditLogs,
};
