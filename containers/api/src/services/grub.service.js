/**
 * LINBO Docker - GRUB Service
 * Generate GRUB configuration files for network boot
 */

const fs = require('fs').promises;
const path = require('path');
const { prisma } = require('../lib/prisma');

const LINBO_DIR = process.env.LINBO_DIR || '/srv/linbo';
const GRUB_DIR = path.join(LINBO_DIR, 'boot/grub');
const HOSTCFG_DIR = path.join(GRUB_DIR, 'hostcfg');

/**
 * Case-insensitive lookup for linboSettings
 * Frontend uses lowercase, backend expects PascalCase
 */
function getLinboSetting(settings, key) {
  if (!settings) return undefined;
  if (settings[key] !== undefined) return settings[key];
  const lowerKey = key.toLowerCase();
  if (settings[lowerKey] !== undefined) return settings[lowerKey];
  for (const k of Object.keys(settings)) {
    if (k.toLowerCase() === lowerKey) return settings[k];
  }
  return undefined;
}

/**
 * Generate GRUB config for a host group
 * Creates: /boot/grub/{groupname}.cfg
 * @param {string} groupName - Name of the host group
 * @param {object} options - Additional options
 * @returns {Promise<{filepath: string, content: string}>}
 */
async function generateGroupGrubConfig(groupName, options = {}) {
  // Get group config if exists
  const group = await prisma.hostGroup.findFirst({
    where: { name: groupName },
    include: {
      defaultConfig: {
        include: {
          osEntries: { orderBy: { position: 'asc' } },
        },
      },
    },
  });

  // Get kernel options from config (case-insensitive lookup)
  let kernelOptions = options.kernelOptions || '';
  const configKernelOpts = getLinboSetting(group?.defaultConfig?.linboSettings, 'KernelOptions');
  if (configKernelOpts) {
    kernelOptions = configKernelOpts;
  }

  // Generate GRUB config content
  const content = `# GRUB config for group: ${groupName}
# Auto-generated by LINBO Docker API
# Generated: ${new Date().toISOString()}

set timeout=0
set group="${groupName}"

# Set default boot parameters
insmod gzio
insmod part_gpt
insmod part_msdos
insmod ext2
insmod all_video

# Load LINBO with group-specific start.conf
linux /linbo64 quiet splash ${kernelOptions} linbo_server=$pxe_default_server group=${groupName}
initrd /linbofs64

boot
`;

  // Ensure GRUB directory exists
  await fs.mkdir(GRUB_DIR, { recursive: true });

  const filepath = path.join(GRUB_DIR, `${groupName}.cfg`);
  await fs.writeFile(filepath, content, 'utf8');

  console.log(`[GrubService] Generated group config: ${filepath}`);

  return { filepath, content };
}

/**
 * Generate GRUB config for a specific host
 * Creates: /boot/grub/hostcfg/{hostname}.cfg
 * @param {string} hostname - Hostname
 * @param {string} groupName - Group name for this host
 * @param {object} options - Additional options
 * @returns {Promise<{filepath: string, content: string}>}
 */
async function generateHostGrubConfig(hostname, groupName, options = {}) {
  // Get host config if exists
  const host = await prisma.host.findFirst({
    where: { hostname },
    include: {
      config: {
        include: {
          osEntries: { orderBy: { position: 'asc' } },
        },
      },
    },
  });

  // Get kernel options from host config or options (case-insensitive lookup)
  let kernelOptions = options.kernelOptions || '';
  const hostKernelOpts = getLinboSetting(host?.config?.linboSettings, 'KernelOptions');
  if (hostKernelOpts) {
    kernelOptions = hostKernelOpts;
  }

  // Generate GRUB config content
  const content = `# GRUB config for host: ${hostname}
# Group: ${groupName}
# Auto-generated by LINBO Docker API
# Generated: ${new Date().toISOString()}

set timeout=0
set group="${groupName}"
set hostname="${hostname}"

# Set default boot parameters
insmod gzio
insmod part_gpt
insmod part_msdos
insmod ext2
insmod all_video

# Load LINBO with host-specific config
linux /linbo64 quiet splash ${kernelOptions} linbo_server=$pxe_default_server group=${groupName} hostname=${hostname}
initrd /linbofs64

boot
`;

  // Ensure host config directory exists
  await fs.mkdir(HOSTCFG_DIR, { recursive: true });

  const filepath = path.join(HOSTCFG_DIR, `${hostname}.cfg`);
  await fs.writeFile(filepath, content, 'utf8');

  console.log(`[GrubService] Generated host config: ${filepath}`);

  return { filepath, content };
}

/**
 * Generate main grub.cfg that chains to group/host configs
 * Creates: /boot/grub/grub.cfg
 * @returns {Promise<{filepath: string, content: string}>}
 */
async function generateMainGrubConfig() {
  const content = `# LINBO Docker - Main GRUB Configuration
# Auto-generated by LINBO Docker API
# Generated: ${new Date().toISOString()}

set timeout=0
set default=0

# Try to load host-specific config first (by hostname)
if [ -f $prefix/hostcfg/$hostname.cfg ]; then
  source $prefix/hostcfg/$hostname.cfg
# Then try group config
elif [ -n "$group" ] && [ -f $prefix/$group.cfg ]; then
  source $prefix/$group.cfg
# Fallback: boot LINBO directly
else
  insmod gzio
  insmod part_gpt
  insmod part_msdos
  insmod ext2
  insmod all_video

  linux /linbo64 quiet splash linbo_server=$pxe_default_server
  initrd /linbofs64
fi

boot
`;

  await fs.mkdir(GRUB_DIR, { recursive: true });

  const filepath = path.join(GRUB_DIR, 'grub.cfg');
  await fs.writeFile(filepath, content, 'utf8');

  console.log(`[GrubService] Generated main grub.cfg: ${filepath}`);

  return { filepath, content };
}

/**
 * Regenerate all GRUB configs for all groups and hosts
 * @returns {Promise<{groups: number, hosts: number, configs: Array}>}
 */
async function regenerateAllGrubConfigs() {
  const results = [];
  let groupCount = 0;
  let hostCount = 0;

  // Generate main grub.cfg
  await generateMainGrubConfig();
  results.push({ type: 'main', name: 'grub.cfg' });

  // Get all groups with their hosts
  const groups = await prisma.hostGroup.findMany({
    include: {
      hosts: true,
      defaultConfig: true,
    },
  });

  for (const group of groups) {
    try {
      // Generate group config
      await generateGroupGrubConfig(group.name);
      results.push({ type: 'group', name: group.name });
      groupCount++;

      // Generate host configs for each host in the group
      for (const host of group.hosts) {
        try {
          await generateHostGrubConfig(host.hostname, group.name);
          results.push({ type: 'host', name: host.hostname, group: group.name });
          hostCount++;
        } catch (error) {
          console.error(`[GrubService] Failed to generate config for host ${host.hostname}:`, error.message);
          results.push({ type: 'host', name: host.hostname, error: error.message });
        }
      }
    } catch (error) {
      console.error(`[GrubService] Failed to generate config for group ${group.name}:`, error.message);
      results.push({ type: 'group', name: group.name, error: error.message });
    }
  }

  // Also handle hosts without a group (orphaned hosts)
  const orphanedHosts = await prisma.host.findMany({
    where: { groupId: null },
  });

  for (const host of orphanedHosts) {
    try {
      await generateHostGrubConfig(host.hostname, 'default');
      results.push({ type: 'host', name: host.hostname, group: 'default' });
      hostCount++;
    } catch (error) {
      console.error(`[GrubService] Failed to generate config for orphaned host ${host.hostname}:`, error.message);
      results.push({ type: 'host', name: host.hostname, error: error.message });
    }
  }

  console.log(`[GrubService] Regenerated ${groupCount} group configs and ${hostCount} host configs`);

  return {
    groups: groupCount,
    hosts: hostCount,
    configs: results,
  };
}

/**
 * Delete GRUB config for a group
 * @param {string} groupName - Group name
 * @returns {Promise<boolean>}
 */
async function deleteGroupGrubConfig(groupName) {
  const filepath = path.join(GRUB_DIR, `${groupName}.cfg`);
  try {
    await fs.unlink(filepath);
    console.log(`[GrubService] Deleted group config: ${filepath}`);
    return true;
  } catch (error) {
    if (error.code !== 'ENOENT') {
      throw error;
    }
    return false;
  }
}

/**
 * Delete GRUB config for a host
 * @param {string} hostname - Hostname
 * @returns {Promise<boolean>}
 */
async function deleteHostGrubConfig(hostname) {
  const filepath = path.join(HOSTCFG_DIR, `${hostname}.cfg`);
  try {
    await fs.unlink(filepath);
    console.log(`[GrubService] Deleted host config: ${filepath}`);
    return true;
  } catch (error) {
    if (error.code !== 'ENOENT') {
      throw error;
    }
    return false;
  }
}

/**
 * List all GRUB configs
 * @returns {Promise<{groups: string[], hosts: string[]}>}
 */
async function listGrubConfigs() {
  const groups = [];
  const hosts = [];

  // List group configs
  try {
    const files = await fs.readdir(GRUB_DIR);
    for (const file of files) {
      if (file.endsWith('.cfg') && file !== 'grub.cfg') {
        groups.push(file.replace('.cfg', ''));
      }
    }
  } catch (error) {
    // Directory doesn't exist
  }

  // List host configs
  try {
    const files = await fs.readdir(HOSTCFG_DIR);
    for (const file of files) {
      if (file.endsWith('.cfg')) {
        hosts.push(file.replace('.cfg', ''));
      }
    }
  } catch (error) {
    // Directory doesn't exist
  }

  return { groups, hosts };
}

/**
 * Cleanup orphaned GRUB configs
 * Removes configs for groups/hosts that no longer exist in the database
 * @returns {Promise<{removedGroups: string[], removedHosts: string[]}>}
 */
async function cleanupOrphanedConfigs() {
  const removedGroups = [];
  const removedHosts = [];

  // Get current groups and hosts from database
  const [dbGroups, dbHosts] = await Promise.all([
    prisma.hostGroup.findMany({ select: { name: true } }),
    prisma.host.findMany({ select: { hostname: true } }),
  ]);

  const validGroups = new Set(dbGroups.map(g => g.name));
  const validHosts = new Set(dbHosts.map(h => h.hostname));

  // List and check group configs
  try {
    const files = await fs.readdir(GRUB_DIR);
    for (const file of files) {
      if (file.endsWith('.cfg') && file !== 'grub.cfg') {
        const groupName = file.replace('.cfg', '');
        if (!validGroups.has(groupName)) {
          await deleteGroupGrubConfig(groupName);
          removedGroups.push(groupName);
        }
      }
    }
  } catch (error) {
    // Directory doesn't exist
  }

  // List and check host configs
  try {
    const files = await fs.readdir(HOSTCFG_DIR);
    for (const file of files) {
      if (file.endsWith('.cfg')) {
        const hostname = file.replace('.cfg', '');
        if (!validHosts.has(hostname)) {
          await deleteHostGrubConfig(hostname);
          removedHosts.push(hostname);
        }
      }
    }
  } catch (error) {
    // Directory doesn't exist
  }

  console.log(`[GrubService] Cleanup: removed ${removedGroups.length} group configs, ${removedHosts.length} host configs`);

  return { removedGroups, removedHosts };
}

module.exports = {
  generateGroupGrubConfig,
  generateHostGrubConfig,
  generateMainGrubConfig,
  regenerateAllGrubConfigs,
  deleteGroupGrubConfig,
  deleteHostGrubConfig,
  listGrubConfigs,
  cleanupOrphanedConfigs,
};
